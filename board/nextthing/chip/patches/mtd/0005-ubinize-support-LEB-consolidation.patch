From 0455782ea16763aa7d0cfdc22d2ffe098232a454 Mon Sep 17 00:00:00 2001
From: Boris Brezillon <boris.brezillon@free-electrons.com>
Date: Thu, 21 Apr 2016 16:32:39 +0200
Subject: [PATCH 5/5] ubinize: support LEB consolidation

Signed-off-by: Richard Weinberger <richard@nod.at>
---
 ubi-utils/include/libubi.h    |   2 +-
 ubi-utils/include/libubigen.h |   8 +-
 ubi-utils/libubigen.c         | 366 +++++++++++++++++++++++++++++++++++-------
 ubi-utils/mtdinfo.c           |   2 +-
 ubi-utils/ubiformat.c         |   6 +-
 ubi-utils/ubinize.c           |   3 +-
 6 files changed, 323 insertions(+), 64 deletions(-)

diff --git a/ubi-utils/include/libubi.h b/ubi-utils/include/libubi.h
index 4d6a7ee..0a4a661 100644
--- a/ubi-utils/include/libubi.h
+++ b/ubi-utils/include/libubi.h
@@ -36,7 +36,7 @@ extern "C" {
 #define LIBUBI_UBI_VERSION 1
 
 /* Maximum physical eraseblock size in bytes */
-#define UBI_MAX_PEB_SZ (2*1024*1024)
+#define UBI_MAX_PEB_SZ (8*1024*1024)
 
 /* UBI library descriptor */
 typedef void * libubi_t;
diff --git a/ubi-utils/include/libubigen.h b/ubi-utils/include/libubigen.h
index c25ac20..45f12ce 100644
--- a/ubi-utils/include/libubigen.h
+++ b/ubi-utils/include/libubigen.h
@@ -36,6 +36,8 @@ extern "C" {
  * struct ubigen_info - libubigen information.
  * @leb_size: logical eraseblock size
  * @peb_size: size of the physical eraseblock
+ * @consolidated_peb_size: size of the physical eraseblock
+ * @clebs_per_peb: Number of consolidated LEB per PEB
  * @min_io_size: minimum input/output unit size
  * @vid_hdr_offs: offset of the VID header
  * @data_offs: data offset
@@ -47,7 +49,9 @@ extern "C" {
 struct ubigen_info
 {
 	int leb_size;
+	int consolidated_peb_size;
 	int peb_size;
+	int clebs_per_peb;
 	int min_io_size;
 	int vid_hdr_offs;
 	int data_offs;
@@ -100,10 +104,12 @@ struct ubigen_vol_info
  * @vid_hdr_offs: offset of the VID header
  * @ubi_ver: UBI version
  * @image_seq: UBI image sequence number
+ * @clebs_per_peb: Number of consolidated LEB per PEB, only used when
+ *		   @ubi_ver > 1.
  */
 void ubigen_info_init(struct ubigen_info *ui, int peb_size, int min_io_size,
 		      int subpage_size, int vid_hdr_offs, int ubi_ver,
-		      uint32_t image_seq);
+		      uint32_t image_seq, int clebs_per_peb);
 
 /**
  * ubigen_create_empty_vtbl - creates empty volume table.
diff --git a/ubi-utils/libubigen.c b/ubi-utils/libubigen.c
index d2a949b..9767b42 100644
--- a/ubi-utils/libubigen.c
+++ b/ubi-utils/libubigen.c
@@ -30,6 +30,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <string.h>
+#include <assert.h>
 
 #include <mtd/ubi-media.h>
 #include <mtd_swab.h>
@@ -37,9 +38,124 @@
 #include <crc32.h>
 #include "common.h"
 
+//TODO: move into libmtd or something like that...
+//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+/**
+ * struct nand_pairing_info - Page pairing information
+ *
+ * @pair: represent the pair index in the paired pages table.For example, if
+ *        page 0 and page 2 are paired together they form the first pair.
+ * @group: the group represent the bit position in the cell. For example,
+ *         page 0 uses bit 0 and is thus part of group 0.
+ */
+struct nand_pairing_info {
+        int pair;
+        int group;
+};
+
+/**
+ * struct nand_pairing_scheme - Page pairing information
+ *
+ * @ngroups: number of groups. Should be related to the number of bits
+ *           per cell.
+ * @get_info: get the paring info of a given write-unit (ie page). This
+ *            function should fill the info struct passed in argument.
+ * @get_page: convert paring information into a write-unit (page) number.
+ */
+struct nand_pairing_scheme {
+        int ngroups;
+        void (*get_info)(const struct ubigen_info *ui, int wunit,
+                         struct nand_pairing_info *info);
+        int (*get_wunit)(const struct ubigen_info *ui,
+                         const struct nand_pairing_info *info);
+};
+
+static void nand_pairing_dist3_get_info(const struct ubigen_info *ui, int page,
+                                        struct nand_pairing_info *info)
+{
+        int lastpage = (ui->consolidated_peb_size / ui->min_io_size) - 1;
+        int dist = 3;
+
+        if (page == lastpage)
+                dist = 2;
+
+        if (!page || (page & 1)) {
+                info->group = 0;
+                info->pair = (page + 1) / 2;
+        } else {
+                info->group = 1;
+                info->pair = (page + 1 - dist) / 2;
+        }
+}
+
+static int nand_pairing_dist3_get_wunit(const struct ubigen_info *ui,
+                                        const struct nand_pairing_info *info)
+{
+        int lastpair = ((ui->consolidated_peb_size / ui->min_io_size) - 1) / 2;
+        int page = info->pair * 2;
+        int dist = 3;
+
+	//printf("pair %i\n", info->pair);
+
+        if (!info->group && !info->pair) {
+                return 0;
+	}
+
+        if (info->pair == lastpair && info->group)
+                dist = 2;
+
+        if (!info->group)
+                page--;
+        else if (info->pair)
+                page += dist - 1;
+
+        assert(page < ui->consolidated_peb_size / ui->min_io_size);
+
+        return page;
+}
+
+static const struct nand_pairing_scheme dist3_pairing_scheme = {
+        .ngroups = 2,
+        .get_info = nand_pairing_dist3_get_info,
+        .get_wunit = nand_pairing_dist3_get_wunit,
+};
+
+int mtd_pairing_info_to_wunit(const struct ubigen_info *ui, const struct nand_pairing_scheme *sch,
+                              struct nand_pairing_info *info)
+{
+        return sch->get_wunit(ui, info);
+}
+
+void copy_soft_slc(const struct ubigen_info *ui, int offset, char *dst, char *src, size_t len)
+{
+	struct nand_pairing_info info;
+	int chunklen, end = offset + len;
+
+	info.pair = offset / ui->min_io_size;
+	info.group = 0;
+
+        while (offset < end) {
+                int realoffs;
+
+		if (ui->min_io_size < end - offset)
+			chunklen = ui->min_io_size;
+		else
+			chunklen = end - offset;
+
+                realoffs = mtd_pairing_info_to_wunit(ui, &dist3_pairing_scheme, &info);
+                realoffs *= ui->min_io_size;
+		assert(realoffs < ui->consolidated_peb_size);
+		memcpy(dst + realoffs, src, chunklen);
+
+                offset += chunklen;
+                src += chunklen;
+                info.pair++;
+        }	
+}
+
 void ubigen_info_init(struct ubigen_info *ui, int peb_size, int min_io_size,
 		      int subpage_size, int vid_hdr_offs, int ubi_ver,
-		      uint32_t image_seq)
+		      uint32_t image_seq, int clebs_per_peb)
 {
 	if (!vid_hdr_offs) {
 		vid_hdr_offs = UBI_EC_HDR_SIZE + subpage_size - 1;
@@ -47,13 +163,20 @@ void ubigen_info_init(struct ubigen_info *ui, int peb_size, int min_io_size,
 		vid_hdr_offs *= subpage_size;
 	}
 
-	ui->peb_size = peb_size;
+	//TODO: prepare for new UBI versioning
+	//if (ubi_ver == 1)
+	//	ui->clebs_per_peb = 1;
+	//else
+		ui->clebs_per_peb = clebs_per_peb;
+
+	ui->consolidated_peb_size = peb_size;
+	ui->peb_size = ui->consolidated_peb_size / ui->clebs_per_peb;
 	ui->min_io_size = min_io_size;
 	ui->vid_hdr_offs = vid_hdr_offs;
 	ui->data_offs = vid_hdr_offs + UBI_VID_HDR_SIZE + min_io_size - 1;
 	ui->data_offs /= min_io_size;
 	ui->data_offs *= min_io_size;
-	ui->leb_size = peb_size - ui->data_offs;
+	ui->leb_size = ui->peb_size - ui->data_offs;
 	ui->ubi_ver = ubi_ver;
 	ui->image_seq = image_seq;
 
@@ -168,12 +291,35 @@ void ubigen_init_vid_hdr(const struct ubigen_info *ui,
 	hdr->hdr_crc = cpu_to_be32(crc);
 }
 
+static bool is_empty(char *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if ((uint8_t)buf[i] != (uint8_t)0xff) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static bool can_consolidate(const struct ubigen_info *ui,
+			    const struct ubigen_vol_info *vi,
+			    char *buf)
+{
+	char *last_page = buf + vi->usable_leb_size - ui->min_io_size;
+
+	return !is_empty(last_page, ui->min_io_size);
+}
+
 int ubigen_write_volume(const struct ubigen_info *ui,
 			const struct ubigen_vol_info *vi, long long ec,
 			long long bytes, int in, int out)
 {
-	int len = vi->usable_leb_size, rd, lnum = 0;
-	char *inbuf, *outbuf;
+	int len = vi->usable_leb_size, rd, lnum = 0, conspos = 0;
+	char *inbuf, *consbuf, *outbuf;
+	struct ubi_vid_hdr *vid_hdrs;
 
 	if (vi->id >= ui->max_volumes) {
 		errmsg("too high volume id %d, max. volumes is %d",
@@ -189,51 +335,101 @@ int ubigen_write_volume(const struct ubigen_info *ui,
 		return -1;
 	}
 
-	inbuf = malloc(ui->leb_size);
+	inbuf = malloc(len);
 	if (!inbuf)
 		return sys_errmsg("cannot allocate %d bytes of memory",
-				  ui->leb_size);
-	outbuf = malloc(ui->peb_size);
+				  len * ui->clebs_per_peb);
+
+	outbuf = malloc(ui->consolidated_peb_size * 2);
 	if (!outbuf) {
-		sys_errmsg("cannot allocate %d bytes of memory", ui->peb_size);
+		sys_errmsg("cannot allocate %d bytes of memory", ui->consolidated_peb_size);
 		goto out_free;
 	}
 
-	memset(outbuf, 0xFF, ui->data_offs);
+	consbuf = outbuf + ui->consolidated_peb_size;
+	vid_hdrs = (struct ubi_vid_hdr *)(consbuf + ui->vid_hdr_offs);
+	memset(outbuf, 0xFF, ui->consolidated_peb_size);
+	memset(consbuf, 0xFF, ui->consolidated_peb_size);
 	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)outbuf, ec);
+	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)consbuf, ec);
 
 	while (bytes) {
-		int l;
-		struct ubi_vid_hdr *vid_hdr;
-
-		if (bytes < len)
-			len = bytes;
-		bytes -= len;
-
-		l = len;
-		do {
-			rd = read(in, inbuf + len - l, l);
-			if (rd != l) {
-				sys_errmsg("cannot read %d bytes from the input file", l);
-				goto out_free1;
+		int readlen = len;
+		bool full;
+
+		if (bytes < readlen) {
+			memset(inbuf + bytes, 0xFF, readlen - bytes);
+			readlen = bytes;
+		}
+		bytes -= readlen;
+
+
+		rd = read(in, inbuf, readlen);
+		if (rd != readlen) {
+			sys_errmsg("cannot read %d bytes from the input file", readlen);
+			goto out_free1;
+		}
+
+		full = can_consolidate(ui, vi, inbuf);
+		if (full) {
+			if (!conspos)
+				memset(consbuf + ui->vid_hdr_offs, 0,
+				       ui->consolidated_peb_size -
+				       ui->vid_hdr_offs);
+			ubigen_init_vid_hdr(ui, vi, &vid_hdrs[conspos],
+					    lnum, inbuf, len);
+			memcpy(consbuf + ui->data_offs + (len * conspos),
+			       inbuf, len);
+
+			if (++conspos == ui->clebs_per_peb) {
+				if (write(out, consbuf, ui->consolidated_peb_size) !=
+				    ui->consolidated_peb_size) {
+					sys_errmsg("cannot write %d bytes to the output file",
+						   ui->consolidated_peb_size);
+					goto out_free1;
+				}
+				conspos = 0;
 			}
+			lnum++;
+		} else {
+			struct ubi_vid_hdr vid_hdr;
 
-			l -= rd;
-		} while (l);
+			assert(len <= vi->usable_leb_size);
 
-		vid_hdr = (struct ubi_vid_hdr *)(&outbuf[ui->vid_hdr_offs]);
-		ubigen_init_vid_hdr(ui, vi, vid_hdr, lnum, inbuf, len);
+			memset(outbuf + ui->vid_hdr_offs, 0, ui->min_io_size);
+			memset(outbuf + ui->data_offs, 0xff,
+			       ui->consolidated_peb_size - ui->data_offs);
 
-		memcpy(outbuf + ui->data_offs, inbuf, len);
-		memset(outbuf + ui->data_offs + len, 0xFF,
-		       ui->peb_size - ui->data_offs - len);
+			ubigen_init_vid_hdr(ui, vi, &vid_hdr, lnum, inbuf, len);
+			copy_soft_slc(ui, ui->vid_hdr_offs, outbuf, (void *)&vid_hdr, sizeof(vid_hdr));
+			copy_soft_slc(ui, ui->data_offs, outbuf, inbuf, len);
+			lnum++;
 
-		if (write(out, outbuf, ui->peb_size) != ui->peb_size) {
-			sys_errmsg("cannot write %d bytes to the output file", ui->peb_size);
-			goto out_free1;
+			if (write(out, outbuf, ui->consolidated_peb_size) !=
+			    ui->consolidated_peb_size) {
+				sys_errmsg("cannot write %d bytes to the output file",
+					   ui->consolidated_peb_size);
+				goto out_free1;
+			}
+		}
+	}
+
+	if (conspos) {
+		if (conspos > 1) {
+			memcpy(outbuf, consbuf, ui->consolidated_peb_size);
+		} else {
+			memcpy(outbuf + ui->vid_hdr_offs,
+			       vid_hdrs, sizeof(*vid_hdrs));
+			copy_soft_slc(ui, ui->data_offs, outbuf,
+				      consbuf + ui->data_offs + len, len);
 		}
 
-		lnum += 1;
+		if (write(out, outbuf, ui->consolidated_peb_size) !=
+		    ui->consolidated_peb_size) {
+			sys_errmsg("cannot write %d bytes to the output file",
+				   ui->consolidated_peb_size);
+			goto out_free1;
+		}
 	}
 
 	free(outbuf);
@@ -247,27 +443,14 @@ out_free:
 	return -1;
 }
 
-int ubigen_write_layout_vol(const struct ubigen_info *ui, int peb1, int peb2,
-			    long long ec1, long long ec2,
-			    struct ubi_vtbl_record *vtbl, int fd)
+static int __write_layout_vol(const struct ubigen_info *ui, const struct ubigen_vol_info *vi,
+			      int peb, int lnum, long long ec, struct ubi_vtbl_record *vtbl, int fd)
 {
 	int ret;
-	struct ubigen_vol_info vi;
 	char *outbuf;
 	struct ubi_vid_hdr *vid_hdr;
 	off_t seek;
 
-	vi.bytes = ui->leb_size * UBI_LAYOUT_VOLUME_EBS;
-	vi.id = UBI_LAYOUT_VOLUME_ID;
-	vi.alignment = UBI_LAYOUT_VOLUME_ALIGN;
-	vi.data_pad = ui->leb_size % UBI_LAYOUT_VOLUME_ALIGN;
-	vi.usable_leb_size = ui->leb_size - vi.data_pad;
-	vi.data_pad = ui->leb_size - vi.usable_leb_size;
-	vi.type = UBI_LAYOUT_VOLUME_TYPE;
-	vi.name = UBI_LAYOUT_VOLUME_NAME;
-	vi.name_len = strlen(UBI_LAYOUT_VOLUME_NAME);
-	vi.compat = UBI_LAYOUT_VOLUME_COMPAT;
-
 	outbuf = malloc(ui->peb_size);
 	if (!outbuf)
 		return sys_errmsg("failed to allocate %d bytes",
@@ -278,31 +461,63 @@ int ubigen_write_layout_vol(const struct ubigen_info *ui, int peb1, int peb2,
 	memcpy(outbuf + ui->data_offs, vtbl, ui->vtbl_size);
 	memset(outbuf + ui->data_offs + ui->vtbl_size, 0xFF,
 	       ui->peb_size - ui->data_offs - ui->vtbl_size);
+	memset(outbuf + ui->vid_hdr_offs, 0, ui->min_io_size);
 
-	seek = (off_t) peb1 * ui->peb_size;
+	seek = (off_t) peb * ui->peb_size;
 	if (lseek(fd, seek, SEEK_SET) != seek) {
 		sys_errmsg("cannot seek output file");
 		goto out_free;
 	}
 
-	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)outbuf, ec1);
-	ubigen_init_vid_hdr(ui, &vi, vid_hdr, 0, NULL, 0);
+	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)outbuf, ec);
+	ubigen_init_vid_hdr(ui, vi, vid_hdr, lnum, NULL, 0);
 	ret = write(fd, outbuf, ui->peb_size);
 	if (ret != ui->peb_size) {
 		sys_errmsg("cannot write %d bytes", ui->peb_size);
 		goto out_free;
 	}
 
-	seek = (off_t) peb2 * ui->peb_size;
+	free(outbuf);
+	return 0;
+
+out_free:
+	free(outbuf);
+	return -1;
+}
+
+static int __write_layout_vol2(const struct ubigen_info *ui, const struct ubigen_vol_info *vi,
+			       int peb, long long ec, struct ubi_vtbl_record *vtbl, int fd)
+{
+	int ret, i;
+	char *outbuf;
+	struct ubi_vid_hdr *vid_hdrs;
+	off_t seek;
+
+	outbuf = malloc(ui->consolidated_peb_size);
+	if (!outbuf)
+		return sys_errmsg("failed to allocate %d bytes",
+				  ui->consolidated_peb_size);
+
+	memset(outbuf, 0x00, ui->consolidated_peb_size);
+	vid_hdrs = (struct ubi_vid_hdr *)(&outbuf[ui->vid_hdr_offs]);
+	memset(outbuf + ui->vid_hdr_offs, 0, ui->min_io_size);
+
+	seek = (off_t) peb * ui->consolidated_peb_size;
 	if (lseek(fd, seek, SEEK_SET) != seek) {
 		sys_errmsg("cannot seek output file");
 		goto out_free;
 	}
-	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)outbuf, ec2);
-	ubigen_init_vid_hdr(ui, &vi, vid_hdr, 1, NULL, 0);
-	ret = write(fd, outbuf, ui->peb_size);
-	if (ret != ui->peb_size) {
-		sys_errmsg("cannot write %d bytes", ui->peb_size);
+
+	ubigen_init_ec_hdr(ui, (struct ubi_ec_hdr *)outbuf, ec);
+
+	for (i = 0; i < ui->clebs_per_peb; i++) {
+		ubigen_init_vid_hdr(ui, vi, &vid_hdrs[i], i, NULL, 0);
+		memcpy(outbuf + ui->data_offs + (vi->usable_leb_size * i), vtbl, ui->vtbl_size);
+	}
+
+	ret = write(fd, outbuf, ui->consolidated_peb_size);
+	if (ret != ui->consolidated_peb_size) {
+		sys_errmsg("cannot write %d bytes", ui->consolidated_peb_size);
 		goto out_free;
 	}
 
@@ -313,3 +528,38 @@ out_free:
 	free(outbuf);
 	return -1;
 }
+
+int ubigen_write_layout_vol(const struct ubigen_info *ui, int peb1, int peb2,
+			    long long ec1, long long ec2,
+			    struct ubi_vtbl_record *vtbl, int fd)
+{
+	int ret;
+	struct ubigen_vol_info vi;
+
+	vi.bytes = ui->leb_size * UBI_LAYOUT_VOLUME_EBS;
+	vi.id = UBI_LAYOUT_VOLUME_ID;
+	vi.alignment = UBI_LAYOUT_VOLUME_ALIGN;
+	vi.data_pad = ui->leb_size % UBI_LAYOUT_VOLUME_ALIGN;
+	vi.usable_leb_size = ui->leb_size - vi.data_pad;
+	vi.data_pad = ui->leb_size - vi.usable_leb_size;
+	vi.type = UBI_LAYOUT_VOLUME_TYPE;
+	vi.name = UBI_LAYOUT_VOLUME_NAME;
+	vi.name_len = strlen(UBI_LAYOUT_VOLUME_NAME);
+	vi.compat = UBI_LAYOUT_VOLUME_COMPAT;
+
+	if (ui->clebs_per_peb > 1)
+		return __write_layout_vol2(ui, &vi, peb1, ec1, vtbl, fd);
+
+	assert(0);
+
+	ret = __write_layout_vol(ui, &vi, peb1, 0, ec1, vtbl, fd);
+	if (ret)
+		goto out;
+
+	ret = __write_layout_vol(ui, &vi, peb2, 1, ec2, vtbl, fd);
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
diff --git a/ubi-utils/mtdinfo.c b/ubi-utils/mtdinfo.c
index a86abd1..6b646ce 100644
--- a/ubi-utils/mtdinfo.c
+++ b/ubi-utils/mtdinfo.c
@@ -168,7 +168,7 @@ static void print_ubi_info(const struct mtd_info *mtd_info,
 	}
 
 	ubigen_info_init(&ui, mtd->eb_size, mtd->min_io_size, mtd->subpage_size,
-			 0, 1, 0);
+			 0, 1, 0, -1);
 	printf("Default UBI VID header offset:  %d\n", ui.vid_hdr_offs);
 	printf("Default UBI data offset:        %d\n", ui.data_offs);
 	printf("Default UBI LEB size:           ");
diff --git a/ubi-utils/ubiformat.c b/ubi-utils/ubiformat.c
index 21409ca..64bfc96 100644
--- a/ubi-utils/ubiformat.c
+++ b/ubi-utils/ubiformat.c
@@ -64,11 +64,13 @@ struct args {
 	const char *image;
 	const char *node;
 	int node_fd;
+	int clebs_per_peb;
 };
 
 static struct args args =
 {
 	.ubi_ver   = 1,
+	.clebs_per_peb = 1,
 };
 
 static const char doc[] = PROGRAM_NAME " version " VERSION
@@ -884,7 +886,7 @@ int main(int argc, char * const argv[])
 		normsg("use erase counter %lld for all eraseblocks", args.ec);
 
 	ubigen_info_init(&ui, mtd.eb_size, mtd.min_io_size, mtd.subpage_size,
-			 args.vid_hdr_offs, args.ubi_ver, args.image_seq);
+			 args.vid_hdr_offs, args.ubi_ver, args.image_seq, -1);
 
 	if (si->vid_hdr_offs != -1 && ui.vid_hdr_offs != si->vid_hdr_offs) {
 		/*
@@ -905,7 +907,7 @@ int main(int argc, char * const argv[])
 		} else
 			ubigen_info_init(&ui, mtd.eb_size, mtd.min_io_size, 0,
 					 si->vid_hdr_offs, args.ubi_ver,
-					 args.image_seq);
+					 args.image_seq, -1);
 		normsg("use offsets %d and %d",  ui.vid_hdr_offs, ui.data_offs);
 	}
 
diff --git a/ubi-utils/ubinize.c b/ubi-utils/ubinize.c
index 34f465a..bdd1ea8 100644
--- a/ubi-utils/ubinize.c
+++ b/ubi-utils/ubinize.c
@@ -462,9 +462,10 @@ int main(int argc, char * const argv[])
 	if (err)
 		return -1;
 
+	//XXX
 	ubigen_info_init(&ui, args.peb_size, args.min_io_size,
 			 args.subpage_size, args.vid_hdr_offs,
-			 args.ubi_ver, args.image_seq);
+			 args.ubi_ver, args.image_seq, 2);
 
 	verbose(args.verbose, "LEB size:                  %d", ui.leb_size);
 	verbose(args.verbose, "PEB size:                  %d", ui.peb_size);
-- 
2.5.0

